//===============================================================================
// LibLog
//
// https://github.com/damianh/LibLog
//===============================================================================
// Copyright Â© 2011-2015 Damian Hickey.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//===============================================================================

// ReSharper disable PossibleNullReferenceException

// Define LIBLOG_PORTABLE conditional compilation symbol for PCL compatibility
//
// Define LIBLOG_PUBLIC to enable ability to GET a logger (LogProvider.For<>() etc) from outside this library. NOTE:
// this can have unintended consequences of consumers of your library using your library to resolve a logger. If the
// reason is because you want to open this functionality to other projects within your solution,
// consider [InternalsVisibleTo] instead.
// 
// Define LIBLOG_PROVIDERS_ONLY if your library provides its own logging API and you just want to use the
// LibLog providers internally to provide built in support for popular logging frameworks.

#pragma warning disable 1591

using System.Diagnostics.CodeAnalysis;
//using DCF.Core.Logging;

[assembly: SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "DCF.Common.Logging")]
[assembly: SuppressMessage("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed", Scope = "member", Target = "DCF.Common.Logging.Logger.#Invoke(DCF.Common.Logging.LogLevel,System.Func`1<System.String>,System.Exception,System.Object[])")]

// If you copied this file manually, you need to change all "YourRootNameSpace" so not to clash with other libraries
// that use LibLog
#if LIBLOG_PROVIDERS_ONLY
namespace DCF.Common.LibLog
#else
namespace DCF.Common.Logging
#endif
{
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
#if LIBLOG_PROVIDERS_ONLY
    using DCF.Common.LibLog.LogProviders;
#else
    using DCF.Common.Logging.LogProviders;
#endif
    using System;
#if !LIBLOG_PROVIDERS_ONLY
    using System.Diagnostics;
#if !LIBLOG_PORTABLE
    using System.Runtime.CompilerServices;
#endif
#endif

#if LIBLOG_PROVIDERS_ONLY
    internal
#else
    public
#endif
    delegate Boolean Logger(LogLevel logLevel, Func<String> messageFunc, Exception exception = null, params Object[] formatParameters);

#if !LIBLOG_PROVIDERS_ONLY
    /// <summary>
    /// Simple interface that represent a logger.
    /// </summary>
#if LIBLOG_PUBLIC
    public
#else
    internal
#endif
    interface ILog
    {
        /// <summary>
        /// Log a message the specified log level.
        /// </summary>
        /// <param name="logLevel">The log level.</param>
        /// <param name="messageFunc">The message function.</param>
        /// <param name="exception">An optional exception.</param>
        /// <param name="formatParameters">Optional format parameters for the message generated by the messagefunc. </param>
        /// <returns>true if the message was logged. Otherwise false.</returns>
        /// <remarks>
        /// Note to implementers: the message func should not be called if the loglevel is not enabled
        /// so as not to incur performance penalties.
        /// 
        /// To check IsEnabled call Log with only LogLevel and check the return value, no event will be written.
        /// </remarks>
        bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception = null, params object[] formatParameters);
    }
#endif

    /// <summary>
    /// The log level.
    /// </summary>
#if LIBLOG_PROVIDERS_ONLY
    internal
#else
    public
#endif
    enum LogLevel
    {
        Trace,
        Debug,
        Info,
        Warn,
        Error,
        Fatal
    }

#if !LIBLOG_PROVIDERS_ONLY
#if LIBLOG_PUBLIC
    public
#else
    internal
#endif
    static partial class LogExtensions
    {
        public static Boolean IsDebugEnabled(this ILog logger)
        {
            GuardAgainstNullLogger(logger);
            return logger.Log(LogLevel.Debug, null);
        }

        public static Boolean IsErrorEnabled(this ILog logger)
        {
            GuardAgainstNullLogger(logger);
            return logger.Log(LogLevel.Error, null);
        }

        public static Boolean IsFatalEnabled(this ILog logger)
        {
            GuardAgainstNullLogger(logger);
            return logger.Log(LogLevel.Fatal, null);
        }

        public static Boolean IsInfoEnabled(this ILog logger)
        {
            GuardAgainstNullLogger(logger);
            return logger.Log(LogLevel.Info, null);
        }

        public static Boolean IsTraceEnabled(this ILog logger)
        {
            GuardAgainstNullLogger(logger);
            return logger.Log(LogLevel.Trace, null);
        }

        public static Boolean IsWarnEnabled(this ILog logger)
        {
            GuardAgainstNullLogger(logger);
            return logger.Log(LogLevel.Warn, null);
        }

        public static void Debug(this ILog logger, Func<String> messageFunc)
        {
            GuardAgainstNullLogger(logger);
            logger.Log(LogLevel.Debug, messageFunc);
        }

        public static void Debug(this ILog logger, String message)
        {
            if (logger.IsDebugEnabled())
            {
                logger.Log(LogLevel.Debug, message.AsFunc());
            }
        }

        public static void DebugFormat(this ILog logger, String message, params Object[] args)
        {
            if (logger.IsDebugEnabled())
            {
                logger.LogFormat(LogLevel.Debug, message, args);
            }
        }

        public static void DebugException(this ILog logger, String message, Exception exception)
        {
            if (logger.IsDebugEnabled())
            {
                logger.Log(LogLevel.Debug, message.AsFunc(), exception);
            }
        }

        public static void DebugException(this ILog logger, String message, Exception exception, params Object[] formatParams)
        {
            if (logger.IsDebugEnabled())
            {
                logger.Log(LogLevel.Debug, message.AsFunc(), exception, formatParams);
            }
        }

        public static void Error(this ILog logger, Func<String> messageFunc)
        {
            GuardAgainstNullLogger(logger);
            logger.Log(LogLevel.Error, messageFunc);
        }

        public static void Error(this ILog logger, String message)
        {
            if (logger.IsErrorEnabled())
            {
                logger.Log(LogLevel.Error, message.AsFunc());
            }
        }

        public static void ErrorFormat(this ILog logger, String message, params Object[] args)
        {
            if (logger.IsErrorEnabled())
            {
                logger.LogFormat(LogLevel.Error, message, args);
            }
        }

        public static void ErrorException(this ILog logger, String message, Exception exception, params Object[] formatParams)
        {
            if (logger.IsErrorEnabled())
            {
                logger.Log(LogLevel.Error, message.AsFunc(), exception, formatParams);
            }
        }

        public static void Fatal(this ILog logger, Func<String> messageFunc)
        {
            logger.Log(LogLevel.Fatal, messageFunc);
        }

        public static void Fatal(this ILog logger, String message)
        {
            if (logger.IsFatalEnabled())
            {
                logger.Log(LogLevel.Fatal, message.AsFunc());
            }
        }

        public static void FatalFormat(this ILog logger, String message, params Object[] args)
        {
            if (logger.IsFatalEnabled())
            {
                logger.LogFormat(LogLevel.Fatal, message, args);
            }
        }

        public static void FatalException(this ILog logger, String message, Exception exception, params Object[] formatParams)
        {
            if (logger.IsFatalEnabled())
            {
                logger.Log(LogLevel.Fatal, message.AsFunc(), exception, formatParams);
            }
        }

        public static void Info(this ILog logger, Func<String> messageFunc)
        {
            GuardAgainstNullLogger(logger);
            logger.Log(LogLevel.Info, messageFunc);
        }

        public static void Info(this ILog logger, String message)
        {
            if (logger.IsInfoEnabled())
            {
                logger.Log(LogLevel.Info, message.AsFunc());
            }
        }

        public static void InfoFormat(this ILog logger, String message, params Object[] args)
        {
            if (logger.IsInfoEnabled())
            {
                logger.LogFormat(LogLevel.Info, message, args);
            }
        }

        public static void InfoException(this ILog logger, String message, Exception exception, params Object[] formatParams)
        {
            if (logger.IsInfoEnabled())
            {
                logger.Log(LogLevel.Info, message.AsFunc(), exception, formatParams);
            }
        }

        public static void Trace(this ILog logger, Func<String> messageFunc)
        {
            GuardAgainstNullLogger(logger);
            logger.Log(LogLevel.Trace, messageFunc);
        }

        public static void Trace(this ILog logger, String message)
        {
            if (logger.IsTraceEnabled())
            {
                logger.Log(LogLevel.Trace, message.AsFunc());
            }
        }

        public static void TraceFormat(this ILog logger, String message, params Object[] args)
        {
            if (logger.IsTraceEnabled())
            {
                logger.LogFormat(LogLevel.Trace, message, args);
            }
        }

        public static void TraceException(this ILog logger, String message, Exception exception, params Object[] formatParams)
        {
            if (logger.IsTraceEnabled())
            {
                logger.Log(LogLevel.Trace, message.AsFunc(), exception, formatParams);
            }
        }

        public static void Warn(this ILog logger, Func<String> messageFunc)
        {
            GuardAgainstNullLogger(logger);
            logger.Log(LogLevel.Warn, messageFunc);
        }

        public static void Warn(this ILog logger, String message)
        {
            if (logger.IsWarnEnabled())
            {
                logger.Log(LogLevel.Warn, message.AsFunc());
            }
        }

        public static void WarnFormat(this ILog logger, String message, params Object[] args)
        {
            if (logger.IsWarnEnabled())
            {
                logger.LogFormat(LogLevel.Warn, message, args);
            }
        }

        public static void WarnException(this ILog logger, String message, Exception exception, params Object[] formatParams)
        {
            if (logger.IsWarnEnabled())
            {
                logger.Log(LogLevel.Warn, message.AsFunc(), exception, formatParams);
            }
        }

        // ReSharper disable once UnusedParameter.Local
        private static void GuardAgainstNullLogger(ILog logger)
        {
            if (logger == null)
            {
                throw new ArgumentNullException("logger");
            }
        }

        private static void LogFormat(this ILog logger, LogLevel logLevel, String message, params Object[] args)
        {
            logger.Log(logLevel, message.AsFunc(), null, args);
        }

        // Avoid the closure allocation, see https://gist.github.com/AArnott/d285feef75c18f6ecd2b
        private static Func<T> AsFunc<T>(this T value) where T : class
        {
            return value.Return;
        }

        private static T Return<T>(this T value)
        {
            return value;
        }
    }
#endif

    /// <summary>
    /// Represents a way to get a <see cref="ILog"/>
    /// </summary>
#if LIBLOG_PROVIDERS_ONLY
    internal
#else
    public
#endif
    interface ILogProvider
    {
        /// <summary>
        /// Gets the specified named logger.
        /// </summary>
        /// <param name="name">Name of the logger.</param>
        /// <returns>The logger reference.</returns>
        Logger GetLogger(String name);

        /// <summary>
        /// Opens a nested diagnostics context. Not supported in EntLib logging.
        /// </summary>
        /// <param name="message">The message to add to the diagnostics context.</param>
        /// <returns>A disposable that when disposed removes the message from the context.</returns>
        IDisposable OpenNestedContext(String message);

        /// <summary>
        /// Opens a mapped diagnostics context. Not supported in EntLib logging.
        /// </summary>
        /// <param name="key">A key.</param>
        /// <param name="value">A value.</param>
        /// <returns>A disposable that when disposed removes the map from the context.</returns>
        IDisposable OpenMappedContext(String key, String value);
    }

    /// <summary>
    /// Provides a mechanism to create instances of <see cref="ILog" /> objects.
    /// </summary>
#if LIBLOG_PROVIDERS_ONLY
    internal
#else
    public
#endif
    static class LogProvider
    {
#if !LIBLOG_PROVIDERS_ONLY
        private const String NullLogProvider = "Current Log Provider is not set. Call SetCurrentLogProvider " +
                                               "with a non-null value first.";
        private static dynamic s_currentLogProvider;
        private static Action<ILogProvider> s_onCurrentLogProviderSet;

        [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        static LogProvider()
        {
            IsDisabled = false;
        }

        /// <summary>
        /// Sets the current log provider.
        /// </summary>
        /// <param name="logProvider">The log provider.</param>
        public static void SetCurrentLogProvider(ILogProvider logProvider)
        {
            s_currentLogProvider = logProvider;

            RaiseOnCurrentLogProviderSet();
        }

        /// <summary>
        /// Gets or sets a value indicating whether this is logging is disabled.
        /// </summary>
        /// <value>
        /// <c>true</c> if logging is disabled; otherwise, <c>false</c>.
        /// </value>
        public static Boolean IsDisabled { get; set; }

        /// <summary>
        /// Sets an action that is invoked when a consumer of your library has called SetCurrentLogProvider. It is 
        /// important that hook into this if you are using child libraries (especially ilmerged ones) that are using
        /// LibLog (or other logging abstraction) so you adapt and delegate to them.
        /// <see cref="SetCurrentLogProvider"/> 
        /// </summary>
        internal static Action<ILogProvider> OnCurrentLogProviderSet
        {
            set
            {
                s_onCurrentLogProviderSet = value;
                RaiseOnCurrentLogProviderSet();
            }
        }

        internal static ILogProvider CurrentLogProvider
        {
            get
            {
                return s_currentLogProvider;
            }
        }

        /// <summary>
        /// Gets a logger for the specified type.
        /// </summary>
        /// <typeparam name="T">The type whose name will be used for the logger.</typeparam>
        /// <returns>An instance of <see cref="ILog"/></returns>
#if LIBLOG_PUBLIC
        public
#else
        internal
#endif
        static ILog For<T>()
        {
            return GetLogger(typeof(T));
        }

#if !LIBLOG_PORTABLE
        /// <summary>
        /// Gets a logger for the current class.
        /// </summary>
        /// <returns>An instance of <see cref="ILog"/></returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
#if LIBLOG_PUBLIC
        public
#else
        internal
#endif
        static ILog GetCurrentClassLogger()
        {
            var stackFrame = new StackFrame(1, false);
            return GetLogger(stackFrame.GetMethod().DeclaringType);
        }
#endif

        /// <summary>
        /// Gets a logger for the specified type.
        /// </summary>
        /// <param name="type">The type whose name will be used for the logger.</param>
        /// <param name="fallbackTypeName">If the type is null then this name will be used as the log name instead</param>
        /// <returns>An instance of <see cref="ILog"/></returns>
#if LIBLOG_PUBLIC
        public
#else
        internal
#endif
        static ILog GetLogger(Type type, String fallbackTypeName = "System.Object")
        {
            // If the type passed in is null then fallback to the type name specified
            return GetLogger(type != null ? type.FullName : fallbackTypeName);
        }

        /// <summary>
        /// Gets a logger with the specified name.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns>An instance of <see cref="ILog"/></returns>
#if LIBLOG_PUBLIC
        public
#else
        internal
#endif
        static ILog GetLogger(String name)
        {
            ILogProvider logProvider = CurrentLogProvider ?? ResolveLogProvider();
            return logProvider == null
                ? NoOpLogger.Instance
                : (ILog)new LoggerExecutionWrapper(logProvider.GetLogger(name), () => IsDisabled);
        }

        /// <summary>
        /// Opens a nested diagnostics context.
        /// </summary>
        /// <param name="message">A message.</param>
        /// <returns>An <see cref="IDisposable"/> that closes context when disposed.</returns>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "SetCurrentLogProvider")]
#if LIBLOG_PUBLIC
        public
#else
        internal
#endif
        static IDisposable OpenNestedContext(String message)
        {
            ILogProvider logProvider = CurrentLogProvider ?? ResolveLogProvider();

            return logProvider == null
                ? new DisposableAction(() => { })
                : logProvider.OpenNestedContext(message);
        }

        /// <summary>
        /// Opens a mapped diagnostics context.
        /// </summary>
        /// <param name="key">A key.</param>
        /// <param name="value">A value.</param>
        /// <returns>An <see cref="IDisposable"/> that closes context when disposed.</returns>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "SetCurrentLogProvider")]
#if LIBLOG_PUBLIC
        public
#else
        internal
#endif
        static IDisposable OpenMappedContext(String key, String value)
        {
            ILogProvider logProvider = CurrentLogProvider ?? ResolveLogProvider();

            return logProvider == null
                ? new DisposableAction(() => { })
                : logProvider.OpenMappedContext(key, value);
        }
#endif

#if LIBLOG_PROVIDERS_ONLY
    private
#else
    internal
#endif
    delegate Boolean IsLoggerAvailable();

#if LIBLOG_PROVIDERS_ONLY
    private
#else
    internal
#endif
    delegate ILogProvider CreateLogProvider();

#if LIBLOG_PROVIDERS_ONLY
    private
#else
    internal
#endif
    static readonly List<Tuple<IsLoggerAvailable, CreateLogProvider>> LogProviderResolvers =
            new List<Tuple<IsLoggerAvailable, CreateLogProvider>>
        {
            new Tuple<IsLoggerAvailable, CreateLogProvider>(SerilogLogProvider.IsLoggerAvailable, () => new SerilogLogProvider()),
            new Tuple<IsLoggerAvailable, CreateLogProvider>(NLogLogProvider.IsLoggerAvailable, () => new NLogLogProvider()),
            new Tuple<IsLoggerAvailable, CreateLogProvider>(Log4NetLogProvider.IsLoggerAvailable, () => new Log4NetLogProvider()),
            new Tuple<IsLoggerAvailable, CreateLogProvider>(EntLibLogProvider.IsLoggerAvailable, () => new EntLibLogProvider()),
            new Tuple<IsLoggerAvailable, CreateLogProvider>(LoupeLogProvider.IsLoggerAvailable, () => new LoupeLogProvider()),
        };

#if !LIBLOG_PROVIDERS_ONLY
        private static void RaiseOnCurrentLogProviderSet()
        {
            if (s_onCurrentLogProviderSet != null)
            {
                s_onCurrentLogProviderSet(s_currentLogProvider);
            }
        }
#endif

        [SuppressMessage("Microsoft.Globalization", "CA1303:Do not pass literals as localized parameters", MessageId = "System.Console.WriteLine(System.String,System.Object,System.Object)")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        internal static ILogProvider ResolveLogProvider()
        {
            try
            {
                foreach (var providerResolver in LogProviderResolvers)
                {
                    if (providerResolver.Item1())
                    {
                        return providerResolver.Item2();
                    }
                }
            }
            catch (Exception ex)
            {
#if LIBLOG_PORTABLE
                Debug.WriteLine(
#else
                Console.WriteLine(
#endif
                    "Exception occurred resolving a log provider. Logging for this assembly {0} is disabled. {1}",
                    typeof(LogProvider).GetAssemblyPortable().FullName,
                    ex);
            }
            return null;
        }



#if !LIBLOG_PROVIDERS_ONLY
    internal class LoggerExecutionWrapper : ILog
    {
        private readonly Logger _logger;
        private readonly Func<Boolean> _getIsDisabled;
        internal const String FailedToGenerateLogMessage = "Failed to generate log message";

        internal LoggerExecutionWrapper(Logger logger, Func<Boolean> getIsDisabled = null)
        {
            _logger = logger;
            _getIsDisabled = getIsDisabled ?? (() => false);
        }

        internal Logger WrappedLogger
        {
            get { return _logger; }
        }

        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public Boolean Log(LogLevel logLevel, Func<String> messageFunc, Exception exception = null, params Object[] formatParameters)
        {
            if (_getIsDisabled())
            {
                return false;
            }
            if (messageFunc == null)
            {
                return _logger(logLevel, null);
            }

            Func<String> wrappedMessageFunc = () =>
            {
                try
                {
                    return messageFunc();
                }
                catch (Exception ex)
                {
                    Log(LogLevel.Error, () => FailedToGenerateLogMessage, ex);
                }
                return null;
            };
            return _logger(logLevel, wrappedMessageFunc, exception, formatParameters);
        }
    }
#endif
}


#if !LIBLOG_PROVIDERS_ONLY
    /// <summary>
    /// Null implementation of the logger used if the host application
    /// does not provided an instance.
    /// </summary>
#if LIBLOG_PUBLIC
    public
#else
    internal
#endif
        class NoOpLogger : ILog
    {
        public Boolean IsTraceEnabled => true;
        public Boolean IsDebugEnabled => true;
        public Boolean IsInfoEnabled => true;
        public Boolean IsWarnEnabled => true;
        public Boolean IsErrorEnabled => true;
        public Boolean IsFatalEnabled => true;

        public List<String> Messages { get; } = new List<String>();

        internal static readonly NoOpLogger Instance = new NoOpLogger();

        public Boolean Log(LogLevel logLevel, Func<String> messageFunc, Exception exception, params Object[] formatParameters)
        {
            if (!this.IsLogLevelEnabled(logLevel))
            {
                return false;
            }

            messageFunc = LogMessageFormatter.SimulateStructuredLogging(messageFunc, formatParameters) ?? (()=> "");
            this.Messages.Add($"{logLevel}:{messageFunc()}; Exception:{exception?.Message ?? String.Empty}");
            return true;
        }

        private Boolean IsLogLevelEnabled(LogLevel logLevel)
        {
            switch (logLevel)
            {
                case LogLevel.Debug:
                    return this.IsDebugEnabled;
                case LogLevel.Info:
                    return this.IsInfoEnabled;
                case LogLevel.Warn:
                    return this.IsWarnEnabled;
                case LogLevel.Error:
                    return this.IsErrorEnabled;
                case LogLevel.Fatal:
                    return this.IsFatalEnabled;
                default:
                    return this.IsTraceEnabled;
            }
        }
    }
#endif
}

#if LIBLOG_PROVIDERS_ONLY
namespace DCF.Common.LibLog.LogProviders
#else
namespace DCF.Common.Logging.LogProviders
#endif
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
#if !LIBLOG_PORTABLE
    using System.Diagnostics;
#endif
    using System.Globalization;
    using System.Linq;
    using System.Linq.Expressions;
    using System.Reflection;
#if !LIBLOG_PORTABLE
    using System.Text;
#endif
    using System.Text.RegularExpressions;

    internal abstract class LogProviderBase : ILogProvider
    {
        protected delegate IDisposable OpenNdc(String message);
        protected delegate IDisposable OpenMdc(String key, String value);

        private readonly Lazy<OpenNdc> _lazyOpenNdcMethod;
        private readonly Lazy<OpenMdc> _lazyOpenMdcMethod;
        private static readonly IDisposable NoopDisposableInstance = new DisposableAction();

        protected LogProviderBase()
        {
            _lazyOpenNdcMethod
                = new Lazy<OpenNdc>(GetOpenNdcMethod);
            _lazyOpenMdcMethod
               = new Lazy<OpenMdc>(GetOpenMdcMethod);
        }

        public abstract Logger GetLogger(String name);

        public IDisposable OpenNestedContext(String message)
        {
            return _lazyOpenNdcMethod.Value(message);
        }

        public IDisposable OpenMappedContext(String key, String value)
        {
            return _lazyOpenMdcMethod.Value(key, value);
        }

        protected virtual OpenNdc GetOpenNdcMethod()
        {
            return _ => NoopDisposableInstance;
        }

        protected virtual OpenMdc GetOpenMdcMethod()
        {
            return (_, __) => NoopDisposableInstance;
        }
    }

    internal class NLogLogProvider : LogProviderBase
    {
        private readonly Func<String, Object> _getLoggerByNameDelegate;
        private static Boolean s_providerIsAvailableOverride = true;

        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "LogManager")]
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "NLog")]
        public NLogLogProvider()
        {
            if (!IsLoggerAvailable())
            {
                throw new InvalidOperationException("NLog.LogManager not found");
            }
            _getLoggerByNameDelegate = GetGetLoggerMethodCall();
        }

        public static Boolean ProviderIsAvailableOverride
        {
            get { return s_providerIsAvailableOverride; }
            set { s_providerIsAvailableOverride = value; }
        }

        public override Logger GetLogger(String name)
        {
            return new NLogLogger(_getLoggerByNameDelegate(name)).Log;
        }

        public static Boolean IsLoggerAvailable()
        {
            return ProviderIsAvailableOverride && GetLogManagerType() != null;
        }

        protected override OpenNdc GetOpenNdcMethod()
        {
            Type ndcContextType = Type.GetType("NLog.NestedDiagnosticsContext, NLog");
            MethodInfo pushMethod = ndcContextType.GetMethodPortable("Push", typeof(String));
            ParameterExpression messageParam = Expression.Parameter(typeof(String), "message");
            MethodCallExpression pushMethodCall = Expression.Call(null, pushMethod, messageParam);
            return Expression.Lambda<OpenNdc>(pushMethodCall, messageParam).Compile();
        }

        protected override OpenMdc GetOpenMdcMethod()
        {
            Type mdcContextType = Type.GetType("NLog.MappedDiagnosticsContext, NLog");

            MethodInfo setMethod = mdcContextType.GetMethodPortable("Set", typeof(String), typeof(String));
            MethodInfo removeMethod = mdcContextType.GetMethodPortable("Remove", typeof(String));
            ParameterExpression keyParam = Expression.Parameter(typeof(String), "key");
            ParameterExpression valueParam = Expression.Parameter(typeof(String), "value");

            MethodCallExpression setMethodCall = Expression.Call(null, setMethod, keyParam, valueParam);
            MethodCallExpression removeMethodCall = Expression.Call(null, removeMethod, keyParam);

            Action<String, String> set = Expression
                .Lambda<Action<String, String>>(setMethodCall, keyParam, valueParam)
                .Compile();
            Action<String> remove = Expression
                .Lambda<Action<String>>(removeMethodCall, keyParam)
                .Compile();

            return (key, value) =>
            {
                set(key, value);
                return new DisposableAction(() => remove(key));
            };
        }

        private static Type GetLogManagerType()
        {
            return Type.GetType("NLog.LogManager, NLog");
        }

        private static Func<String, Object> GetGetLoggerMethodCall()
        {
            Type logManagerType = GetLogManagerType();
            MethodInfo method = logManagerType.GetMethodPortable("GetLogger", typeof(String));
            ParameterExpression nameParam = Expression.Parameter(typeof(String), "name");
            MethodCallExpression methodCall = Expression.Call(null, method, nameParam);
            return Expression.Lambda<Func<String, Object>>(methodCall, nameParam).Compile();
        }

        internal class NLogLogger
        {
            private readonly dynamic _logger;

            private static Func<String, Object, String, Exception, Object> _logEventInfoFact;

            private static readonly Object _levelTrace;
            private static readonly Object _levelDebug;
            private static readonly Object _levelInfo;
            private static readonly Object _levelWarn;
            private static readonly Object _levelError;
            private static readonly Object _levelFatal;

            static NLogLogger()
            {
                try
                {
                    var logEventLevelType = Type.GetType("NLog.LogLevel, NLog");
                    if (logEventLevelType == null)
                    {
                        throw new InvalidOperationException("Type NLog.LogLevel was not found.");
                    }

                    var levelFields = logEventLevelType.GetFieldsPortable().ToList();
                    _levelTrace = levelFields.First(x => x.Name == "Trace").GetValue(null);
                    _levelDebug = levelFields.First(x => x.Name == "Debug").GetValue(null);
                    _levelInfo = levelFields.First(x => x.Name == "Info").GetValue(null);
                    _levelWarn = levelFields.First(x => x.Name == "Warn").GetValue(null);
                    _levelError = levelFields.First(x => x.Name == "Error").GetValue(null);
                    _levelFatal = levelFields.First(x => x.Name == "Fatal").GetValue(null);

                    var logEventInfoType = Type.GetType("NLog.LogEventInfo, NLog");
                    if (logEventInfoType == null)
                    {
                        throw new InvalidOperationException("Type NLog.LogEventInfo was not found.");
                    }
                    MethodInfo createLogEventInfoMethodInfo = logEventInfoType.GetMethodPortable("Create",
                        logEventLevelType, typeof(String), typeof(Exception), typeof(IFormatProvider), typeof(String), typeof(Object[]));
                    ParameterExpression loggerNameParam = Expression.Parameter(typeof(String));
                    ParameterExpression levelParam = Expression.Parameter(typeof(Object));
                    ParameterExpression messageParam = Expression.Parameter(typeof(String));
                    ParameterExpression exceptionParam = Expression.Parameter(typeof(Exception));
                    UnaryExpression levelCast = Expression.Convert(levelParam, logEventLevelType);
                    MethodCallExpression createLogEventInfoMethodCall = Expression.Call(null,
                        createLogEventInfoMethodInfo,
                        levelCast, loggerNameParam, exceptionParam,
                        Expression.Constant(null, typeof(IFormatProvider)), messageParam, Expression.Constant(null, typeof(Object[])));
                    _logEventInfoFact = Expression.Lambda<Func<String, Object, String, Exception, Object>>(createLogEventInfoMethodCall,
                        loggerNameParam, levelParam, messageParam, exceptionParam).Compile();
                }
                catch { }
            }

            internal NLogLogger(dynamic logger)
            {
                _logger = logger;
            }

            [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
            public Boolean Log(LogLevel logLevel, Func<String> messageFunc, Exception exception, params Object[] formatParameters)
            {
                if (messageFunc == null)
                {
                    return IsLogLevelEnable(logLevel);
                }
                messageFunc = LogMessageFormatter.SimulateStructuredLogging(messageFunc, formatParameters);

                if (_logEventInfoFact != null)
                {
                    if (IsLogLevelEnable(logLevel))
                    {
                        var nlogLevel = this.TranslateLevel(logLevel);
                        Type s_callerStackBoundaryType;
#if !LIBLOG_PORTABLE
                        StackTrace stack = new StackTrace();
                        Type thisType = GetType();
                        Type knownType0 = typeof(LogProvider.LoggerExecutionWrapper);
                        Type knownType1 = typeof(LogExtensions);
                        //Maybe inline, so we may can't found any LibLog classes in stack
                        s_callerStackBoundaryType = null;
                        for (var i = 0; i < stack.FrameCount; i++)
                        {
                            var declaringType = stack.GetFrame(i).GetMethod().DeclaringType;
                            if (!IsInTypeHierarchy(thisType, declaringType) &&
                                !IsInTypeHierarchy(knownType0, declaringType) &&
                                !IsInTypeHierarchy(knownType1, declaringType))
                            {
                                if (i > 1)
                                    s_callerStackBoundaryType = stack.GetFrame(i - 1).GetMethod().DeclaringType;
                                break;
                            }
                        }
#else
                        s_callerStackBoundaryType = null;
#endif
                        if (s_callerStackBoundaryType != null)
                            _logger.Log(s_callerStackBoundaryType, _logEventInfoFact(_logger.Name, nlogLevel, messageFunc(), exception));
                        else
                            _logger.Log(_logEventInfoFact(_logger.Name, nlogLevel, messageFunc(), exception));
                        return true;
                    }
                    return false;
                }

                if(exception != null)
                {
                    return LogException(logLevel, messageFunc, exception);
                }
                switch (logLevel)
                {
                    case LogLevel.Debug:
                        if (_logger.IsDebugEnabled)
                        {
                            _logger.Debug(messageFunc());
                            return true;
                        }
                        break;
                    case LogLevel.Info:
                        if (_logger.IsInfoEnabled)
                        {
                            _logger.Info(messageFunc());
                            return true;
                        }
                        break;
                    case LogLevel.Warn:
                        if (_logger.IsWarnEnabled)
                        {
                            _logger.Warn(messageFunc());
                            return true;
                        }
                        break;
                    case LogLevel.Error:
                        if (_logger.IsErrorEnabled)
                        {
                            _logger.Error(messageFunc());
                            return true;
                        }
                        break;
                    case LogLevel.Fatal:
                        if (_logger.IsFatalEnabled)
                        {
                            _logger.Fatal(messageFunc());
                            return true;
                        }
                        break;
                    default:
                        if (_logger.IsTraceEnabled)
                        {
                            _logger.Trace(messageFunc());
                            return true;
                        }
                        break;
                }
                return false;
            }

            private static Boolean IsInTypeHierarchy(Type currentType, Type checkType)
            {
                while (currentType != null && currentType != typeof(Object))
                {
                    if (currentType == checkType)
                    {
                        return true;
                    }
                    currentType = currentType.GetBaseTypePortable();
                }
                return false;
            }

            [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
            private Boolean LogException(LogLevel logLevel, Func<String> messageFunc, Exception exception)
            {
                switch (logLevel)
                {
                    case LogLevel.Debug:
                        if (_logger.IsDebugEnabled)
                        {
                            _logger.DebugException(messageFunc(), exception);
                            return true;
                        }
                        break;
                    case LogLevel.Info:
                        if (_logger.IsInfoEnabled)
                        {
                            _logger.InfoException(messageFunc(), exception);
                            return true;
                        }
                        break;
                    case LogLevel.Warn:
                        if (_logger.IsWarnEnabled)
                        {
                            _logger.WarnException(messageFunc(), exception);
                            return true;
                        }
                        break;
                    case LogLevel.Error:
                        if (_logger.IsErrorEnabled)
                        {
                            _logger.ErrorException(messageFunc(), exception);
                            return true;
                        }
                        break;
                    case LogLevel.Fatal:
                        if (_logger.IsFatalEnabled)
                        {
                            _logger.FatalException(messageFunc(), exception);
                            return true;
                        }
                        break;
                    default:
                        if (_logger.IsTraceEnabled)
                        {
                            _logger.TraceException(messageFunc(), exception);
                            return true;
                        }
                        break;
                }
                return false;
            }

            private Boolean IsLogLevelEnable(LogLevel logLevel)
            {
                switch (logLevel)
                {
                    case LogLevel.Debug:
                        return _logger.IsDebugEnabled;
                    case LogLevel.Info:
                        return _logger.IsInfoEnabled;
                    case LogLevel.Warn:
                        return _logger.IsWarnEnabled;
                    case LogLevel.Error:
                        return _logger.IsErrorEnabled;
                    case LogLevel.Fatal:
                        return _logger.IsFatalEnabled;
                    default:
                        return _logger.IsTraceEnabled;
                }
            }

            private Object TranslateLevel(LogLevel logLevel)
            {
                switch (logLevel)
                {
                    case LogLevel.Trace:
                        return _levelTrace;
                    case LogLevel.Debug:
                        return _levelDebug;
                    case LogLevel.Info:
                        return _levelInfo;
                    case LogLevel.Warn:
                        return _levelWarn;
                    case LogLevel.Error:
                        return _levelError;
                    case LogLevel.Fatal:
                        return _levelFatal;
                    default:
                        throw new ArgumentOutOfRangeException("logLevel", logLevel, null);
                }
            }
        }
    }

    internal class Log4NetLogProvider : LogProviderBase
    {
        private readonly Func<String, Object> _getLoggerByNameDelegate;
        private static Boolean s_providerIsAvailableOverride = true;

        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "LogManager")]
        public Log4NetLogProvider()
        {
            if (!IsLoggerAvailable())
            {
                throw new InvalidOperationException("log4net.LogManager not found");
            }
            _getLoggerByNameDelegate = GetGetLoggerMethodCall();
        }

        public static Boolean ProviderIsAvailableOverride
        {
            get { return s_providerIsAvailableOverride; }
            set { s_providerIsAvailableOverride = value; }
        }

        public override Logger GetLogger(String name)
        {
            return new Log4NetLogger(_getLoggerByNameDelegate(name)).Log;
        }

        internal static Boolean IsLoggerAvailable()
        {
            return ProviderIsAvailableOverride && GetLogManagerType() != null;
        }

        protected override OpenNdc GetOpenNdcMethod()
        {
            Type logicalThreadContextType = Type.GetType("log4net.LogicalThreadContext, log4net");
            PropertyInfo stacksProperty = logicalThreadContextType.GetPropertyPortable("Stacks");
            Type logicalThreadContextStacksType = stacksProperty.PropertyType;
            PropertyInfo stacksIndexerProperty = logicalThreadContextStacksType.GetPropertyPortable("Item");
            Type stackType = stacksIndexerProperty.PropertyType;
            MethodInfo pushMethod = stackType.GetMethodPortable("Push");

            ParameterExpression messageParameter =
                Expression.Parameter(typeof(String), "message");

            // message => LogicalThreadContext.Stacks.Item["NDC"].Push(message);
            MethodCallExpression callPushBody =
                Expression.Call(
                    Expression.Property(Expression.Property(null, stacksProperty),
                                        stacksIndexerProperty,
                                        Expression.Constant("NDC")),
                    pushMethod,
                    messageParameter);

            OpenNdc result =
                Expression.Lambda<OpenNdc>(callPushBody, messageParameter)
                          .Compile();

            return result;
        }

        protected override OpenMdc GetOpenMdcMethod()
        {
            Type logicalThreadContextType = Type.GetType("log4net.LogicalThreadContext, log4net");
            PropertyInfo propertiesProperty = logicalThreadContextType.GetPropertyPortable("Properties");
            Type logicalThreadContextPropertiesType = propertiesProperty.PropertyType;
            PropertyInfo propertiesIndexerProperty = logicalThreadContextPropertiesType.GetPropertyPortable("Item");

            MethodInfo removeMethod = logicalThreadContextPropertiesType.GetMethodPortable("Remove");

            ParameterExpression keyParam = Expression.Parameter(typeof(String), "key");
            ParameterExpression valueParam = Expression.Parameter(typeof(String), "value");

            MemberExpression propertiesExpression = Expression.Property(null, propertiesProperty);

            // (key, value) => LogicalThreadContext.Properties.Item[key] = value;
            BinaryExpression setProperties = Expression.Assign(Expression.Property(propertiesExpression, propertiesIndexerProperty, keyParam), valueParam);

            // key => LogicalThreadContext.Properties.Remove(key);
            MethodCallExpression removeMethodCall = Expression.Call(propertiesExpression, removeMethod, keyParam);

            Action<String, String> set = Expression
                .Lambda<Action<String, String>>(setProperties, keyParam, valueParam)
                .Compile();

            Action<String> remove = Expression
                .Lambda<Action<String>>(removeMethodCall, keyParam)
                .Compile();

            return (key, value) =>
            {
                set(key, value);
                return new DisposableAction(() => remove(key));
            };
        }

        private static Type GetLogManagerType()
        {
            return Type.GetType("log4net.LogManager, log4net");
        }

        private static Func<String, Object> GetGetLoggerMethodCall()
        {
            Type logManagerType = GetLogManagerType();
            MethodInfo method = logManagerType.GetMethodPortable("GetLogger", typeof(String));
            ParameterExpression nameParam = Expression.Parameter(typeof(String), "name");
            MethodCallExpression methodCall = Expression.Call(null, method, nameParam);
            return Expression.Lambda<Func<String, Object>>(methodCall, nameParam).Compile();
        }

        internal class Log4NetLogger
        {
            private readonly dynamic _logger;
            private static Type s_callerStackBoundaryType;
            private static readonly Object CallerStackBoundaryTypeSync = new Object();

            private readonly Object _levelDebug;
            private readonly Object _levelInfo;
            private readonly Object _levelWarn;
            private readonly Object _levelError;
            private readonly Object _levelFatal;
            private readonly Func<Object, Object, Boolean> _isEnabledForDelegate;
            private readonly Action<Object, Object> _logDelegate;
            private readonly Func<Object, Type, Object, String, Exception, Object> _createLoggingEvent;
            private Action<Object, String, Object> _loggingEventPropertySetter;

            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "ILogger")]
            internal Log4NetLogger(dynamic logger)
            {
                _logger = logger.Logger;

                var logEventLevelType = Type.GetType("log4net.Core.Level, log4net");
                if (logEventLevelType == null)
                {
                    throw new InvalidOperationException("Type log4net.Core.Level was not found.");
                }

                var levelFields = logEventLevelType.GetFieldsPortable().ToList();
                _levelDebug = levelFields.First(x => x.Name == "Debug").GetValue(null);
                _levelInfo = levelFields.First(x => x.Name == "Info").GetValue(null);
                _levelWarn = levelFields.First(x => x.Name == "Warn").GetValue(null);
                _levelError = levelFields.First(x => x.Name == "Error").GetValue(null);
                _levelFatal = levelFields.First(x => x.Name == "Fatal").GetValue(null);

                // Func<object, object, bool> isEnabledFor = (logger, level) => { return ((log4net.Core.ILogger)logger).IsEnabled(level); }
                var loggerType = Type.GetType("log4net.Core.ILogger, log4net");
                if (loggerType == null)
                {
                    throw new InvalidOperationException("Type log4net.Core.ILogger, was not found.");
                }
                ParameterExpression instanceParam = Expression.Parameter(typeof(Object));
                UnaryExpression instanceCast = Expression.Convert(instanceParam, loggerType);
                ParameterExpression levelParam = Expression.Parameter(typeof(Object));
                UnaryExpression levelCast = Expression.Convert(levelParam, logEventLevelType);
                _isEnabledForDelegate = GetIsEnabledFor(loggerType, logEventLevelType, instanceCast, levelCast, instanceParam, levelParam);

                Type loggingEventType = Type.GetType("log4net.Core.LoggingEvent, log4net");

                _createLoggingEvent = GetCreateLoggingEvent(instanceParam, instanceCast, levelParam, levelCast, loggingEventType);

                _logDelegate = GetLogDelegate(loggerType, loggingEventType, instanceCast, instanceParam);

                _loggingEventPropertySetter = GetLoggingEventPropertySetter(loggingEventType);
            }

            private static Action<Object, Object> GetLogDelegate(Type loggerType, Type loggingEventType, UnaryExpression instanceCast,
                                                 ParameterExpression instanceParam)
            {
                //Action<object, object, string, Exception> Log =
                //(logger, callerStackBoundaryDeclaringType, level, message, exception) => { ((ILogger)logger).Log(new LoggingEvent(callerStackBoundaryDeclaringType, logger.Repository, logger.Name, level, message, exception)); }
                MethodInfo writeExceptionMethodInfo = loggerType.GetMethodPortable("Log",
                                                                                   loggingEventType);

                ParameterExpression loggingEventParameter =
                    Expression.Parameter(typeof(Object), "loggingEvent");

                UnaryExpression loggingEventCasted =
                    Expression.Convert(loggingEventParameter, loggingEventType);

                var writeMethodExp = Expression.Call(
                    instanceCast,
                    writeExceptionMethodInfo,
                    loggingEventCasted);

                var logDelegate = Expression.Lambda<Action<Object, Object>>(
                                                writeMethodExp,
                                                instanceParam,
                                                loggingEventParameter).Compile();

                return logDelegate;
            }

            private static Func<Object, Type, Object, String, Exception, Object> GetCreateLoggingEvent(ParameterExpression instanceParam, UnaryExpression instanceCast, ParameterExpression levelParam, UnaryExpression levelCast, Type loggingEventType)
            {
                ParameterExpression callerStackBoundaryDeclaringTypeParam = Expression.Parameter(typeof(Type));
                ParameterExpression messageParam = Expression.Parameter(typeof(String));
                ParameterExpression exceptionParam = Expression.Parameter(typeof(Exception));

                PropertyInfo repositoryProperty = loggingEventType.GetPropertyPortable("Repository");
                PropertyInfo levelProperty = loggingEventType.GetPropertyPortable("Level");

                ConstructorInfo loggingEventConstructor =
                    loggingEventType.GetConstructorPortable(typeof(Type), repositoryProperty.PropertyType, typeof(String), levelProperty.PropertyType, typeof(Object), typeof(Exception));

                //Func<object, object, string, Exception, object> Log =
                //(logger, callerStackBoundaryDeclaringType, level, message, exception) => new LoggingEvent(callerStackBoundaryDeclaringType, ((ILogger)logger).Repository, ((ILogger)logger).Name, (Level)level, message, exception); }
                NewExpression newLoggingEventExpression =
                    Expression.New(loggingEventConstructor,
                                   callerStackBoundaryDeclaringTypeParam,
                                   Expression.Property(instanceCast, "Repository"),
                                   Expression.Property(instanceCast, "Name"),
                                   levelCast,
                                   messageParam,
                                   exceptionParam);

                var createLoggingEvent =
                    Expression.Lambda<Func<Object, Type, Object, String, Exception, Object>>(
                                  newLoggingEventExpression,
                                  instanceParam,
                                  callerStackBoundaryDeclaringTypeParam,
                                  levelParam,
                                  messageParam,
                                  exceptionParam)
                              .Compile();

                return createLoggingEvent;
            }

            private static Func<Object, Object, Boolean> GetIsEnabledFor(Type loggerType, Type logEventLevelType,
                                                                      UnaryExpression instanceCast,
                                                                      UnaryExpression levelCast,
                                                                      ParameterExpression instanceParam,
                                                                      ParameterExpression levelParam)
            {
                MethodInfo isEnabledMethodInfo = loggerType.GetMethodPortable("IsEnabledFor", logEventLevelType);
                MethodCallExpression isEnabledMethodCall = Expression.Call(instanceCast, isEnabledMethodInfo, levelCast);

                Func<Object, Object, Boolean> result =
                    Expression.Lambda<Func<Object, Object, Boolean>>(isEnabledMethodCall, instanceParam, levelParam)
                              .Compile();

                return result;
            }

            private static Action<Object, String, Object> GetLoggingEventPropertySetter(Type loggingEventType)
            {
                ParameterExpression loggingEventParameter = Expression.Parameter(typeof(Object), "loggingEvent");
                ParameterExpression keyParameter = Expression.Parameter(typeof(String), "key");
                ParameterExpression valueParameter = Expression.Parameter(typeof(Object), "value");

                PropertyInfo propertiesProperty = loggingEventType.GetPropertyPortable("Properties");
                PropertyInfo item = propertiesProperty.PropertyType.GetPropertyPortable("Item");

                // ((LoggingEvent)loggingEvent).Properties[key] = value;
                var body =
                    Expression.Assign(
                        Expression.Property(
                            Expression.Property(Expression.Convert(loggingEventParameter, loggingEventType),
                                                propertiesProperty), item, keyParameter), valueParameter);

                Action<Object, String, Object> result =
                    Expression.Lambda<Action<Object, String, Object>>
                              (body, loggingEventParameter, keyParameter,
                               valueParameter)
                              .Compile();

                return result;
            }

            public Boolean Log(LogLevel logLevel, Func<String> messageFunc, Exception exception, params Object[] formatParameters)
            {
                if (messageFunc == null)
                {
                    return IsLogLevelEnable(logLevel);
                }

                if (!IsLogLevelEnable(logLevel))
                {
                    return false;
                }

                String message = messageFunc();

                IEnumerable<String> patternMatches;

                String formattedMessage =
                    LogMessageFormatter.FormatStructuredMessage(message,
                                                                formatParameters,
                                                                out patternMatches);

                // determine correct caller - this might change due to jit optimizations with method inlining
                if (s_callerStackBoundaryType == null)
                {
                    lock (CallerStackBoundaryTypeSync)
                    {
#if !LIBLOG_PORTABLE
                        StackTrace stack = new StackTrace();
                        Type thisType = GetType();
                        s_callerStackBoundaryType = Type.GetType("LoggerExecutionWrapper");
                        for (var i = 1; i < stack.FrameCount; i++)
                        {
                            if (!IsInTypeHierarchy(thisType, stack.GetFrame(i).GetMethod().DeclaringType))
                            {
                                s_callerStackBoundaryType = stack.GetFrame(i - 1).GetMethod().DeclaringType;
                                break;
                            }
                        }
#else
                        s_callerStackBoundaryType = typeof (LoggerExecutionWrapper);
#endif
                    }
                }

                var translatedLevel = TranslateLevel(logLevel);

                Object loggingEvent = _createLoggingEvent(_logger, s_callerStackBoundaryType, translatedLevel, formattedMessage, exception);

                PopulateProperties(loggingEvent, patternMatches, formatParameters);

                _logDelegate(_logger, loggingEvent);

                return true;
            }

            private void PopulateProperties(Object loggingEvent, IEnumerable<String> patternMatches, Object[] formatParameters)
            {
                IEnumerable<KeyValuePair<String, Object>> keyToValue =
                    patternMatches.Zip(formatParameters,
                                       (key, value) => new KeyValuePair<String, Object>(key, value));

                foreach (KeyValuePair<String, Object> keyValuePair in keyToValue)
                {
                    _loggingEventPropertySetter(loggingEvent, keyValuePair.Key, keyValuePair.Value);
                }
            }

            private static Boolean IsInTypeHierarchy(Type currentType, Type checkType)
            {
                while (currentType != null && currentType != typeof(Object))
                {
                    if (currentType == checkType)
                    {
                        return true;
                    }
                    currentType = currentType.GetBaseTypePortable();
                }
                return false;
            }

            private Boolean IsLogLevelEnable(LogLevel logLevel)
            {
                var level = TranslateLevel(logLevel);
                return _isEnabledForDelegate(_logger, level);
            }

            private Object TranslateLevel(LogLevel logLevel)
            {
                switch (logLevel)
                {
                    case LogLevel.Trace:
                    case LogLevel.Debug:
                        return _levelDebug;
                    case LogLevel.Info:
                        return _levelInfo;
                    case LogLevel.Warn:
                        return _levelWarn;
                    case LogLevel.Error:
                        return _levelError;
                    case LogLevel.Fatal:
                        return _levelFatal;
                    default:
                        throw new ArgumentOutOfRangeException("logLevel", logLevel, null);
                }
            }
        }
    }

    internal class EntLibLogProvider : LogProviderBase
    {
        private const String TypeTemplate = "Microsoft.Practices.EnterpriseLibrary.Logging.{0}, Microsoft.Practices.EnterpriseLibrary.Logging";
        private static Boolean s_providerIsAvailableOverride = true;
        private static readonly Type LogEntryType;
        private static readonly Type LoggerType;
        private static readonly Type TraceEventTypeType;
        private static readonly Action<String, String, Int32> WriteLogEntry;
        private static readonly Func<String, Int32, Boolean> ShouldLogEntry;

        [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        static EntLibLogProvider()
        {
            LogEntryType = Type.GetType(String.Format(CultureInfo.InvariantCulture, TypeTemplate, "LogEntry"));
            LoggerType = Type.GetType(String.Format(CultureInfo.InvariantCulture, TypeTemplate, "Logger"));
            TraceEventTypeType = TraceEventTypeValues.Type;
            if (LogEntryType == null
                 || TraceEventTypeType == null
                 || LoggerType == null)
            {
                return;
            }
            WriteLogEntry = GetWriteLogEntry();
            ShouldLogEntry = GetShouldLogEntry();
        }

        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "EnterpriseLibrary")]
        public EntLibLogProvider()
        {
            if (!IsLoggerAvailable())
            {
                throw new InvalidOperationException("Microsoft.Practices.EnterpriseLibrary.Logging.Logger not found");
            }
        }

        public static Boolean ProviderIsAvailableOverride
        {
            get { return s_providerIsAvailableOverride; }
            set { s_providerIsAvailableOverride = value; }
        }

        public override Logger GetLogger(String name)
        {
            return new EntLibLogger(name, WriteLogEntry, ShouldLogEntry).Log;
        }

        internal static Boolean IsLoggerAvailable()
        {
            return ProviderIsAvailableOverride
                 && TraceEventTypeType != null
                 && LogEntryType != null;
        }

        private static Action<String, String, Int32> GetWriteLogEntry()
        {
            // new LogEntry(...)
            var logNameParameter = Expression.Parameter(typeof(String), "logName");
            var messageParameter = Expression.Parameter(typeof(String), "message");
            var severityParameter = Expression.Parameter(typeof(Int32), "severity");

            MemberInitExpression memberInit = GetWriteLogExpression(
                messageParameter,
                Expression.Convert(severityParameter, TraceEventTypeType),
                logNameParameter);

            //Logger.Write(new LogEntry(....));
            MethodInfo writeLogEntryMethod = LoggerType.GetMethodPortable("Write", LogEntryType);
            var writeLogEntryExpression = Expression.Call(writeLogEntryMethod, memberInit);

            return Expression.Lambda<Action<String, String, Int32>>(
                writeLogEntryExpression,
                logNameParameter,
                messageParameter,
                severityParameter).Compile();
        }

        private static Func<String, Int32, Boolean> GetShouldLogEntry()
        {
            // new LogEntry(...)
            var logNameParameter = Expression.Parameter(typeof(String), "logName");
            var severityParameter = Expression.Parameter(typeof(Int32), "severity");

            MemberInitExpression memberInit = GetWriteLogExpression(
                Expression.Constant("***dummy***"),
                Expression.Convert(severityParameter, TraceEventTypeType),
                logNameParameter);

            //Logger.Write(new LogEntry(....));
            MethodInfo writeLogEntryMethod = LoggerType.GetMethodPortable("ShouldLog", LogEntryType);
            var writeLogEntryExpression = Expression.Call(writeLogEntryMethod, memberInit);

            return Expression.Lambda<Func<String, Int32, Boolean>>(
                writeLogEntryExpression,
                logNameParameter,
                severityParameter).Compile();
        }

        private static MemberInitExpression GetWriteLogExpression(Expression message,
            Expression severityParameter, ParameterExpression logNameParameter)
        {
            var entryType = LogEntryType;
            MemberInitExpression memberInit = Expression.MemberInit(Expression.New(entryType),
                Expression.Bind(entryType.GetPropertyPortable("Message"), message),
                Expression.Bind(entryType.GetPropertyPortable("Severity"), severityParameter),
                Expression.Bind(
                    entryType.GetPropertyPortable("TimeStamp"),
                    Expression.Property(null, typeof (DateTime).GetPropertyPortable("UtcNow"))),
                Expression.Bind(
                    entryType.GetPropertyPortable("Categories"),
                    Expression.ListInit(
                        Expression.New(typeof (List<String>)),
                        typeof (List<String>).GetMethodPortable("Add", typeof (String)),
                        logNameParameter)));
            return memberInit;
        }

        internal class EntLibLogger
        {
            private readonly String _loggerName;
            private readonly Action<String, String, Int32> _writeLog;
            private readonly Func<String, Int32, Boolean> _shouldLog;

            internal EntLibLogger(String loggerName, Action<String, String, Int32> writeLog, Func<String, Int32, Boolean> shouldLog)
            {
                _loggerName = loggerName;
                _writeLog = writeLog;
                _shouldLog = shouldLog;
            }

            public Boolean Log(LogLevel logLevel, Func<String> messageFunc, Exception exception, params Object[] formatParameters)
            {
                var severity = MapSeverity(logLevel);
                if (messageFunc == null)
                {
                    return _shouldLog(_loggerName, severity);
                }


                messageFunc = LogMessageFormatter.SimulateStructuredLogging(messageFunc, formatParameters);
                if (exception != null)
                {
                    return LogException(logLevel, messageFunc, exception);
                }
                _writeLog(_loggerName, messageFunc(), severity);
                return true;
            }

            public Boolean LogException(LogLevel logLevel, Func<String> messageFunc, Exception exception)
            {
                var severity = MapSeverity(logLevel);
                var message = messageFunc() + Environment.NewLine + exception;
                _writeLog(_loggerName, message, severity);
                return true;
            }

            private static Int32 MapSeverity(LogLevel logLevel)
            {
                switch (logLevel)
                {
                    case LogLevel.Fatal:
                        return TraceEventTypeValues.Critical;
                    case LogLevel.Error:
                        return TraceEventTypeValues.Error;
                    case LogLevel.Warn:
                        return TraceEventTypeValues.Warning;
                    case LogLevel.Info:
                        return TraceEventTypeValues.Information;
                    default:
                        return TraceEventTypeValues.Verbose;
                }
            }
        }
    }

    internal class SerilogLogProvider : LogProviderBase
    {
        private readonly Func<String, Object> _getLoggerByNameDelegate;
        private static Boolean s_providerIsAvailableOverride = true;

        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "Serilog")]
        public SerilogLogProvider()
        {
            if (!IsLoggerAvailable())
            {
                throw new InvalidOperationException("Serilog.Log not found");
            }
            _getLoggerByNameDelegate = GetForContextMethodCall();
        }

        public static Boolean ProviderIsAvailableOverride
        {
            get { return s_providerIsAvailableOverride; }
            set { s_providerIsAvailableOverride = value; }
        }

        public override Logger GetLogger(String name)
        {
            return new SerilogLogger(_getLoggerByNameDelegate(name)).Log;
        }

        internal static Boolean IsLoggerAvailable()
        {
            return ProviderIsAvailableOverride && GetLogManagerType() != null;
        }

        protected override OpenNdc GetOpenNdcMethod()
        {
            return message => GetPushProperty()("NDC", message);
        }

        protected override OpenMdc GetOpenMdcMethod()
        {
            return (key, value) => GetPushProperty()(key, value);
        }

        private static Func<String, String, IDisposable> GetPushProperty()
        {
            Type ndcContextType = Type.GetType("Serilog.Context.LogContext, Serilog") ?? 
                                  Type.GetType("Serilog.Context.LogContext, Serilog.FullNetFx");

            MethodInfo pushPropertyMethod = ndcContextType.GetMethodPortable(
                "PushProperty", 
                typeof(String),
                typeof(Object),
                typeof(Boolean));

            ParameterExpression nameParam = Expression.Parameter(typeof(String), "name");
            ParameterExpression valueParam = Expression.Parameter(typeof(Object), "value");
            ParameterExpression destructureObjectParam = Expression.Parameter(typeof(Boolean), "destructureObjects");
            MethodCallExpression pushPropertyMethodCall = Expression
                .Call(null, pushPropertyMethod, nameParam, valueParam, destructureObjectParam);
            var pushProperty = Expression
                .Lambda<Func<String, Object, Boolean, IDisposable>>(
                    pushPropertyMethodCall,
                    nameParam,
                    valueParam,
                    destructureObjectParam)
                .Compile();
            
            return (key, value) => pushProperty(key, value, false);
        }

        private static Type GetLogManagerType()
        {
            return Type.GetType("Serilog.Log, Serilog");
        }

        private static Func<String, Object> GetForContextMethodCall()
        {
            Type logManagerType = GetLogManagerType();
            MethodInfo method = logManagerType.GetMethodPortable("ForContext", typeof(String), typeof(Object), typeof(Boolean));
            ParameterExpression propertyNameParam = Expression.Parameter(typeof(String), "propertyName");
            ParameterExpression valueParam = Expression.Parameter(typeof(Object), "value");
            ParameterExpression destructureObjectsParam = Expression.Parameter(typeof(Boolean), "destructureObjects");
            MethodCallExpression methodCall = Expression.Call(null, method, new Expression[]
            {
                propertyNameParam, 
                valueParam,
                destructureObjectsParam
            });
            var func = Expression.Lambda<Func<String, Object, Boolean, Object>>(
                methodCall,
                propertyNameParam,
                valueParam,
                destructureObjectsParam)
                .Compile();
            return name => func("SourceContext", name, false);
        }

        internal class SerilogLogger
        {
            private readonly Object _logger;
            private static readonly Object DebugLevel;
            private static readonly Object ErrorLevel;
            private static readonly Object FatalLevel;
            private static readonly Object InformationLevel;
            private static readonly Object VerboseLevel;
            private static readonly Object WarningLevel;
            private static readonly Func<Object, Object, Boolean> IsEnabled;
            private static readonly Action<Object, Object, String, Object[]> Write;
            private static readonly Action<Object, Object, Exception, String, Object[]> WriteException;

            [SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
            [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "ILogger")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "LogEventLevel")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "Serilog")]
            static SerilogLogger()
            {
                var logEventLevelType = Type.GetType("Serilog.Events.LogEventLevel, Serilog");
                if (logEventLevelType == null)
                {
                    throw new InvalidOperationException("Type Serilog.Events.LogEventLevel was not found.");
                }
                DebugLevel = Enum.Parse(logEventLevelType, "Debug", false);
                ErrorLevel = Enum.Parse(logEventLevelType, "Error", false);
                FatalLevel = Enum.Parse(logEventLevelType, "Fatal", false);
                InformationLevel = Enum.Parse(logEventLevelType, "Information", false);
                VerboseLevel = Enum.Parse(logEventLevelType, "Verbose", false);
                WarningLevel = Enum.Parse(logEventLevelType, "Warning", false);

                // Func<object, object, bool> isEnabled = (logger, level) => { return ((SeriLog.ILogger)logger).IsEnabled(level); }
                var loggerType = Type.GetType("Serilog.ILogger, Serilog");
                if (loggerType == null)
                {
                    throw new InvalidOperationException("Type Serilog.ILogger was not found.");
                }
                MethodInfo isEnabledMethodInfo = loggerType.GetMethodPortable("IsEnabled", logEventLevelType);
                ParameterExpression instanceParam = Expression.Parameter(typeof(Object));
                UnaryExpression instanceCast = Expression.Convert(instanceParam, loggerType);
                ParameterExpression levelParam = Expression.Parameter(typeof(Object));
                UnaryExpression levelCast = Expression.Convert(levelParam, logEventLevelType);
                MethodCallExpression isEnabledMethodCall = Expression.Call(instanceCast, isEnabledMethodInfo, levelCast);
                IsEnabled = Expression.Lambda<Func<Object, Object, Boolean>>(isEnabledMethodCall, instanceParam, levelParam).Compile();

                // Action<object, object, string> Write =
                // (logger, level, message, params) => { ((SeriLog.ILoggerILogger)logger).Write(level, message, params); }
                MethodInfo writeMethodInfo = loggerType.GetMethodPortable("Write", logEventLevelType, typeof(String), typeof(Object[]));
                ParameterExpression messageParam = Expression.Parameter(typeof(String));
                ParameterExpression propertyValuesParam = Expression.Parameter(typeof(Object[]));
                MethodCallExpression writeMethodExp = Expression.Call(
                    instanceCast,
                    writeMethodInfo,
                    levelCast,
                    messageParam,
                    propertyValuesParam);
                var expression = Expression.Lambda<Action<Object, Object, String, Object[]>>(
                    writeMethodExp, 
                    instanceParam,
                    levelParam,
                    messageParam,
                    propertyValuesParam);
                Write = expression.Compile();

                // Action<object, object, string, Exception> WriteException =
                // (logger, level, exception, message) => { ((ILogger)logger).Write(level, exception, message, new object[]); }
                MethodInfo writeExceptionMethodInfo = loggerType.GetMethodPortable("Write", 
                    logEventLevelType,
                    typeof(Exception),
                    typeof(String),
                    typeof(Object[]));
                ParameterExpression exceptionParam = Expression.Parameter(typeof(Exception));
                writeMethodExp = Expression.Call(
                    instanceCast,
                    writeExceptionMethodInfo,
                    levelCast,
                    exceptionParam,
                    messageParam,
                    propertyValuesParam);
                WriteException = Expression.Lambda<Action<Object, Object, Exception, String, Object[]>>(
                    writeMethodExp, 
                    instanceParam,
                    levelParam,
                    exceptionParam,
                    messageParam,
                    propertyValuesParam).Compile();
            }

            internal SerilogLogger(Object logger)
            {
                _logger = logger;
            }

            public Boolean Log(LogLevel logLevel, Func<String> messageFunc, Exception exception, params Object[] formatParameters)
            {
                var translatedLevel = TranslateLevel(logLevel);
                if (messageFunc == null)
                {
                    return IsEnabled(_logger, translatedLevel);
                }

                if (!IsEnabled(_logger, translatedLevel))
                {
                    return false;
                }

                if (exception != null)
                {
                    LogException(translatedLevel, messageFunc, exception, formatParameters);
                }
                else
                {
                    LogMessage(translatedLevel, messageFunc, formatParameters);
                }

                return true;
            }

            private void LogMessage(Object translatedLevel, Func<String> messageFunc, Object[] formatParameters)
            {
                Write(_logger, translatedLevel, messageFunc(), formatParameters);
            }

            private void LogException(Object logLevel, Func<String> messageFunc, Exception exception, Object[] formatParams)
            {
                WriteException(_logger, logLevel, exception, messageFunc(), formatParams);
            }

            private static Object TranslateLevel(LogLevel logLevel)
            {
                switch (logLevel)
                {
                    case LogLevel.Fatal:
                        return FatalLevel;
                    case LogLevel.Error:
                        return ErrorLevel;
                    case LogLevel.Warn:
                        return WarningLevel;
                    case LogLevel.Info:
                        return InformationLevel;
                    case LogLevel.Trace:
                        return VerboseLevel;
                    default:
                        return DebugLevel;
                }
            }
        }
    }

    internal class LoupeLogProvider : LogProviderBase
    {
        /// <summary>
        /// The form of the Loupe Log.Write method we're using
        /// </summary>
        internal delegate void WriteDelegate(
            Int32 severity,
            String logSystem,
            Int32 skipFrames,
            Exception exception,
            Boolean attributeToException,
            Int32 writeMode,
            String detailsXml,
            String category,
            String caption,
            String description,
            params Object[] args
            );

        private static Boolean s_providerIsAvailableOverride = true;
        private readonly WriteDelegate _logWriteDelegate;

        public LoupeLogProvider()
        {
            if (!IsLoggerAvailable())
            {
                throw new InvalidOperationException("Gibraltar.Agent.Log (Loupe) not found");
            }

            _logWriteDelegate = GetLogWriteDelegate();
        }

        /// <summary>
        /// Gets or sets a value indicating whether [provider is available override]. Used in tests.
        /// </summary>
        /// <value>
        /// <c>true</c> if [provider is available override]; otherwise, <c>false</c>.
        /// </value>
        public static Boolean ProviderIsAvailableOverride
        {
            get { return s_providerIsAvailableOverride; }
            set { s_providerIsAvailableOverride = value; }
        }

        public override Logger GetLogger(String name)
        {
            return new LoupeLogger(name, _logWriteDelegate).Log;
        }

        public static Boolean IsLoggerAvailable()
        {
            return ProviderIsAvailableOverride && GetLogManagerType() != null;
        }

        private static Type GetLogManagerType()
        {
            return Type.GetType("Gibraltar.Agent.Log, Gibraltar.Agent");
        }

        private static WriteDelegate GetLogWriteDelegate()
        {
            Type logManagerType = GetLogManagerType();
            Type logMessageSeverityType = Type.GetType("Gibraltar.Agent.LogMessageSeverity, Gibraltar.Agent");
            Type logWriteModeType = Type.GetType("Gibraltar.Agent.LogWriteMode, Gibraltar.Agent");

            MethodInfo method = logManagerType.GetMethodPortable(
                "Write",
                logMessageSeverityType, typeof(String), typeof(Int32), typeof(Exception), typeof(Boolean), 
                logWriteModeType, typeof(String), typeof(String), typeof(String), typeof(String), typeof(Object[]));

            var callDelegate = (WriteDelegate)method.CreateDelegate(typeof(WriteDelegate));
            return callDelegate;
        }

        internal class LoupeLogger
        {
            private const String LogSystem = "LibLog";

            private readonly String _category;
            private readonly WriteDelegate _logWriteDelegate;
            private readonly Int32 _skipLevel;

            internal LoupeLogger(String category, WriteDelegate logWriteDelegate)
            {
                _category = category;
                _logWriteDelegate = logWriteDelegate;
#if DEBUG
                _skipLevel = 2;
#else
                _skipLevel = 1;
#endif
            }

            public Boolean Log(LogLevel logLevel, Func<String> messageFunc, Exception exception, params Object[] formatParameters)
            {
                if (messageFunc == null)
                {
                    //nothing to log..
                    return true;
                }

                messageFunc = LogMessageFormatter.SimulateStructuredLogging(messageFunc, formatParameters);

                _logWriteDelegate(ToLogMessageSeverity(logLevel), LogSystem, _skipLevel, exception, true, 0, null,
                    _category, null, messageFunc.Invoke());

                return true;
            }

            private static Int32 ToLogMessageSeverity(LogLevel logLevel)
            {
                switch (logLevel)
                {
                    case LogLevel.Trace:
                        return TraceEventTypeValues.Verbose;
                    case LogLevel.Debug:
                        return TraceEventTypeValues.Verbose;
                    case LogLevel.Info:
                        return TraceEventTypeValues.Information;
                    case LogLevel.Warn:
                        return TraceEventTypeValues.Warning;
                    case LogLevel.Error:
                        return TraceEventTypeValues.Error;
                    case LogLevel.Fatal:
                        return TraceEventTypeValues.Critical;
                    default:
                        throw new ArgumentOutOfRangeException("logLevel");
                }
            }
        }
    }

    internal static class TraceEventTypeValues
    {
        internal static readonly Type Type;
        internal static readonly Int32 Verbose;
        internal static readonly Int32 Information;
        internal static readonly Int32 Warning;
        internal static readonly Int32 Error;
        internal static readonly Int32 Critical;

        [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        static TraceEventTypeValues()
        {
            var assembly = typeof(Uri).GetAssemblyPortable(); // This is to get to the System.dll assembly in a PCL compatible way.
            if (assembly == null)
            {
                return;
            }
            Type = assembly.GetType("System.Diagnostics.TraceEventType");
            if (Type == null) return;
            Verbose = (Int32)Enum.Parse(Type, "Verbose", false);
            Information = (Int32)Enum.Parse(Type, "Information", false);
            Warning = (Int32)Enum.Parse(Type, "Warning", false);
            Error = (Int32)Enum.Parse(Type, "Error", false);
            Critical = (Int32)Enum.Parse(Type, "Critical", false);
        }
    }

    internal static class LogMessageFormatter
    {
        //private static readonly Regex Pattern = new Regex(@"\{@?\w{1,}\}");
#if LIBLOG_PORTABLE
        private static readonly Regex Pattern = new Regex(@"(?<!{){@?(?<arg>[^\d{][^ }]*)}");
#else
        private static readonly Regex Pattern = new Regex(@"(?<!{){@?(?<arg>[^ :{}]+)(?<format>:[^}]+)?}", RegexOptions.Compiled);
#endif

        /// <summary>
        /// Some logging frameworks support structured logging, such as serilog. This will allow you to add names to structured data in a format string:
        /// For example: Log("Log message to {user}", user). This only works with serilog, but as the user of LibLog, you don't know if serilog is actually 
        /// used. So, this class simulates that. it will replace any text in {curly braces} with an index number. 
        /// 
        /// "Log {message} to {user}" would turn into => "Log {0} to {1}". Then the format parameters are handled using regular .net string.Format.
        /// </summary>
        /// <param name="messageBuilder">The message builder.</param>
        /// <param name="formatParameters">The format parameters.</param>
        /// <returns></returns>
        public static Func<String> SimulateStructuredLogging(Func<String> messageBuilder, Object[] formatParameters)
        {
            if (formatParameters == null || formatParameters.Length == 0)
            {
                return messageBuilder;
            }

            return () =>
            {
                String targetMessage = messageBuilder();
                IEnumerable<String> patternMatches;
                return FormatStructuredMessage(targetMessage, formatParameters, out patternMatches);
            };
        }

        private static String ReplaceFirst(String text, String search, String replace)
        {
            Int32 pos = text.IndexOf(search, StringComparison.Ordinal);
            if (pos < 0)
            {
                return text;
            }
            return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);
        }

        public static String FormatStructuredMessage(String targetMessage, Object[] formatParameters, out IEnumerable<String> patternMatches)
        {
            if (formatParameters.Length == 0)
            {
                patternMatches = Enumerable.Empty<String>();
                return targetMessage;
            }

            List<String> processedArguments = new List<String>();
            patternMatches = processedArguments;

            foreach (Match match in Pattern.Matches(targetMessage))
            {
                var arg = match.Groups["arg"].Value;

                Int32 notUsed;
                if (!Int32.TryParse(arg, out notUsed))
                {
                    Int32 argumentIndex = processedArguments.IndexOf(arg);
                    if (argumentIndex == -1)
                    {
                        argumentIndex = processedArguments.Count;
                        processedArguments.Add(arg);
                    }

                    targetMessage = ReplaceFirst(targetMessage, match.Value,
                        "{" + argumentIndex + match.Groups["format"].Value + "}");
                }
            }
            try
            {
                return String.Format(CultureInfo.InvariantCulture, targetMessage, formatParameters);
            }
            catch (FormatException ex)
            {
                throw new FormatException("The input string '" + targetMessage + "' could not be formatted using string.Format", ex);
            }
        }
    }

    internal static class TypeExtensions
    {
        internal static ConstructorInfo GetConstructorPortable(this Type type, params Type[] types)
        {
#if LIBLOG_PORTABLE
            return type.GetTypeInfo().DeclaredConstructors.FirstOrDefault
                       (constructor =>
                            constructor.GetParameters()
                                       .Select(parameter => parameter.ParameterType)
                                       .SequenceEqual(types));
#else
            return type.GetConstructor(types);
#endif
        }

        internal static MethodInfo GetMethodPortable(this Type type, String name)
        {
#if LIBLOG_PORTABLE
            return type.GetRuntimeMethods().SingleOrDefault(m => m.Name == name);
#else
            return type.GetMethod(name);
#endif
        }

        internal static MethodInfo GetMethodPortable(this Type type, String name, params Type[] types)
        {
#if LIBLOG_PORTABLE
            return type.GetRuntimeMethod(name, types);
#else
            return type.GetMethod(name, types);
#endif
        }

        internal static PropertyInfo GetPropertyPortable(this Type type, String name)
        {
#if LIBLOG_PORTABLE
            return type.GetRuntimeProperty(name);
#else
            return type.GetProperty(name);
#endif
        }

        internal static IEnumerable<FieldInfo> GetFieldsPortable(this Type type)
        {
#if LIBLOG_PORTABLE
            return type.GetRuntimeFields();
#else
            return type.GetFields();
#endif
        }

        internal static Type GetBaseTypePortable(this Type type)
        {
#if LIBLOG_PORTABLE
            return type.GetTypeInfo().BaseType;
#else
            return type.BaseType;
#endif
        }

#if LIBLOG_PORTABLE
        internal static MethodInfo GetGetMethod(this PropertyInfo propertyInfo)
        {
            return propertyInfo.GetMethod;
        }

        internal static MethodInfo GetSetMethod(this PropertyInfo propertyInfo)
        {
            return propertyInfo.SetMethod;
        }
#endif

#if !LIBLOG_PORTABLE
        internal static Object CreateDelegate(this MethodInfo methodInfo, Type delegateType)
        {
            return Delegate.CreateDelegate(delegateType, methodInfo);
        }
#endif

        internal static Assembly GetAssemblyPortable(this Type type)
        {
#if LIBLOG_PORTABLE
            return type.GetTypeInfo().Assembly;
#else
            return type.Assembly;
#endif
        }
    }

    internal class DisposableAction : IDisposable
    {
        private readonly Action _onDispose;

        public DisposableAction(Action onDispose = null)
        {
            _onDispose = onDispose;
        }

        public void Dispose()
        {
            if(_onDispose != null)
            {
                _onDispose();
            }
        }
    }
}
